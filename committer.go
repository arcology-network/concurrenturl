/*
 *   Copyright (c) 2024 Arcology Network

 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.

 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.

 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// Package storagecommitter provides functionality for committing storage changes to url2a datastore.
package storagecommitter

import (
	"errors"
	"math"
	"runtime"

	platform "github.com/arcology-network/storage-committer/platform"
	"github.com/arcology-network/storage-committer/storage"
	"github.com/arcology-network/storage-committer/univalue"
	ethcommon "github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"

	"github.com/arcology-network/common-lib/common"
	"github.com/arcology-network/common-lib/exp/associative"
	mapi "github.com/arcology-network/common-lib/exp/map"
	"github.com/arcology-network/common-lib/exp/slice"
	importer "github.com/arcology-network/storage-committer/importer"
	interfaces "github.com/arcology-network/storage-committer/interfaces"
	intf "github.com/arcology-network/storage-committer/interfaces"
)

// StateCommitter represents a storage committer.
type StateCommitter struct {
	store interfaces.Datastore
	// store    storage.StoreRouter
	Platform *platform.Platform

	byPath *Indexer[string, *univalue.Univalue, []*univalue.Univalue]
	byTxID *Indexer[uint32, *univalue.Univalue, []*univalue.Univalue]
	byEth  *Indexer[[20]byte, *univalue.Univalue, *associative.Pair[*storage.Account, []*univalue.Univalue]]
	byCtrn []*univalue.Univalue

	Err error
}

// NewStorageCommitter creates a new StateCommitter instance.
func NewStorageCommitter(store interfaces.Datastore) *StateCommitter {
	plat := platform.NewPlatform()

	return &StateCommitter{
		store:    store,
		Platform: plat, //[]stgcommcommon.FilteredTransitionsInterface{&importer.NonceFilter{}, &importer.BalanceFilter{}},

		// An index by path, transitions have the same path will be put together in a list
		// This index will be used for apply transitions on the original state. So all the transitions
		// should be put into this index.
		byPath: NewIndexer(
			store,
			func(v *univalue.Univalue) (string, bool) {
				return *(*v).GetPath(), true
			},
			nil,
			func(_ string, v *univalue.Univalue) []*univalue.Univalue { return []*univalue.Univalue{v} },
			func(_ string, v *univalue.Univalue, vals *[]*univalue.Univalue) { *vals = append(*vals, v) },
		),
		// An index by tx number, transitions have the same tx number will be put together in a list.
		// This index will be used to remove the transitions generated by the conflicting transactions.
		// So, the immutable transitions should not be put into this index.
		byTxID: NewIndexer(
			store,
			func(v *univalue.Univalue) (uint32, bool) {
				if !v.Persistent() {
					return v.GetTx(), true
				}
				return math.MaxUint32, false
			},
			nil,
			func(_ uint32, v *univalue.Univalue) []*univalue.Univalue { return []*univalue.Univalue{v} },
			func(_ uint32, v *univalue.Univalue, vals *[]*univalue.Univalue) { *vals = append(*vals, v) },
		),

		// An index by account address, transitions have the same account address will be put together in a list
		// This is for ETH storage, concurrent container related sub-paths won't be put into this index.
		byEth: NewIndexer(
			store,
			func(v *univalue.Univalue) ([20]byte, bool) {
				if !platform.IsEthPath(*v.GetPath()) {
					return [20]byte{}, false
				}
				addr, _ := hexutil.Decode(platform.GetAccountAddr(*v.GetPath()))
				return ethcommon.BytesToAddress(addr), platform.IsEthPath(*v.GetPath())
			},
			nil,
			func(addr [20]byte, v *univalue.Univalue) *associative.Pair[*storage.Account, []*univalue.Univalue] {
				return &associative.Pair[*storage.Account, []*univalue.Univalue]{
					First:  store.Preload(addr[:]).(*storage.Account),
					Second: []*univalue.Univalue{v},
				}
			},
			func(_ [20]byte, v *univalue.Univalue, pair **associative.Pair[*storage.Account, []*univalue.Univalue]) {
				(**pair).Second = append((**pair).Second, v)
			},
		),

		// This index records the transitions that are related to the concurrent containers
		// The transitions will be put into the index if the account address is a concurrent container and
		// later stored in the concurrent container storage, which is different from the ETH storage.
		// All the transitions will be under the same key.
		// byCtrn: NewIndexer(
		// 	store,
		// 	func(v *univalue.Univalue) (string, bool) {
		// 		return *v.GetPath(), !platform.IsEthPath(*v.GetPath()) // All under the same key
		// 	},
		// 	nil,
		// 	func(_ string, v *univalue.Univalue) []*univalue.Univalue { return []*univalue.Univalue{v} },
		// 	func(_ string, v *univalue.Univalue, vals *[]*univalue.Univalue) { *vals = append(*vals, v) },
		// ),
		byCtrn: []*univalue.Univalue{},
	}
}

// New creates a new StateCommitter instance.
func (this *StateCommitter) New(args ...interface{}) *StateCommitter {
	return &StateCommitter{
		Platform: platform.NewPlatform(),
	}
}

// Importer returns the importer of the StateCommitter.
func (this *StateCommitter) Store() interfaces.Datastore     { return this.store }
func (this *StateCommitter) Init(store interfaces.Datastore) {}

// Init initializes the StateCommitter with the given datastore.
// func (this *StateCommitter) Init(store interfaces.Datastore) {
// 	this.importer.Init(store)
// 	this.imuImporter.Init(store)
// }

// Import imports the given transitions into the StateCommitter.
func (this *StateCommitter) Import(transitions []*univalue.Univalue, args ...interface{}) *StateCommitter {
	this.byPath.Add(transitions)
	this.byTxID.Add(transitions)
	this.byEth.Add(transitions)
	// this.byCtrn.Add(transitions)

	for _, v := range transitions {
		if v.GetPath() != nil || !platform.IsEthPath(*v.GetPath()) {
			this.byCtrn = append(this.byCtrn, v)
		}
	}
	return this
}

// Finalize finalizes the transitions in the StateCommitter.
func (this *StateCommitter) Whitelist(txs []uint32) *StateCommitter {
	if len(txs) == 0 {
		return this
	}

	whitelistDict := mapi.FromSlice(txs, func(_ uint32) bool { return true })
	this.byTxID.ParallelForeachDo(func(txid uint32, vec *[]*univalue.Univalue) {
		if _, ok := whitelistDict[uint32(txid)]; !ok {
			for _, v := range *vec {
				v.SetPath(nil) // Mark the transition status, so that it can be removed later.
			}
		}
	})
	return this
}

// Finalize finalizes the transitions in the StateCommitter.
func (this *StateCommitter) Finalize(txs []uint32) *StateCommitter {
	this.byPath.ParallelForeachDo(func(_ string, v *[]*univalue.Univalue) {
		importer.DeltaSequenceV2(*v).Finalize()
	})
	return this
}

// Commit commits the transitions in the StateCommitter.
func (this *StateCommitter) Precommit(txs []uint32) [32]byte {
	this.Whitelist(txs)

	// Finalize all the transitions for both the ETH storage and the concurrent container transitions
	this.byPath.ParallelForeachDo(func(_ string, v *[]*univalue.Univalue) {
		slice.RemoveIf(v, func(_ int, val *univalue.Univalue) bool { return val.GetPath() == nil }) // Remove conflicting ones.
		if len(*v) > 0 {
			importer.DeltaSequenceV2(*v).Finalize()
		}
	})

	var ethRootHash [32]byte
	common.ParallelExecute(
		func() {
			slice.RemoveIf(&this.byCtrn, func(_ int, v *univalue.Univalue) bool { return v.GetPath() == nil }) // Remove the transitions that are marked
			keys := univalue.Univalues(this.byCtrn).Keys()
			vals := slice.To[*univalue.Univalue, interface{}](this.byCtrn)
			this.Store().(*storage.StoreRouter).CCStore().Precommit(keys, vals)
		},

		func() {
			this.byEth.ParallelForeachDo(func(_ [20]byte, v **associative.Pair[*storage.Account, []*univalue.Univalue]) {
				slice.RemoveIf(&((**v).Second), func(_ int, v *univalue.Univalue) bool { return v.GetPath() == nil })
			})
			ethRootHash = this.Store().(*storage.StoreRouter).EthStore().Precommit(this.byEth.Values())
		},
	)
	return ethRootHash // Write to the DB buffer
}

// Commit commits the transitions in the StateCommitter.
func (this *StateCommitter) Commit(blockNum uint64) *StateCommitter {
	var ethStgErr, ccStgErr error
	common.ParallelExecute(
		func() {
			trans := slice.Flatten(this.byPath.Values())
			slice.RemoveIf(&trans, func(_ int, v *univalue.Univalue) bool { return v.GetPath() == nil }) // Remove conflict ones
			this.CommitToCache(blockNum, trans)
		},
		func() { ccStgErr = this.Store().(*storage.StoreRouter).CCStore().Commit(blockNum) },
		func() { ethStgErr = this.Store().(*storage.StoreRouter).EthStore().Commit(blockNum) },
	)
	this.Err = errors.Join(ethStgErr, ccStgErr)
	return this
}

// Update the cache
func (this *StateCommitter) CommitToCache(blockNum uint64, trans []*univalue.Univalue) {
	keys := make([]string, len(trans))
	typedVals := slice.ParallelTransform(trans, runtime.NumCPU(), func(i int, v *univalue.Univalue) intf.Type {
		keys[i] = *v.GetPath()
		if v.Value() != nil {
			return v.Value().(intf.Type)
		}
		return nil // A deletion
	})
	this.Store().(*storage.StoreRouter).RefreshCache(blockNum, keys, typedVals) // Update the cache
}

// Clear clears the StateCommitter.
func (this *StateCommitter) Clear() {
	this.byPath.Clear()
	this.byTxID.Clear()
	this.byEth.Clear()
	this.byCtrn = this.byCtrn[:0]
}
