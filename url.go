package concurrenturl

import (
	"github.com/arcology-network/common-lib/common"
	committercommon "github.com/arcology-network/concurrenturl/common"

	indexer "github.com/arcology-network/concurrenturl/indexer"
	interfaces "github.com/arcology-network/concurrenturl/interfaces"
)

type StorageCommitter struct {
	importer    *indexer.Importer
	imuImporter *indexer.Importer // transitions that will take effect anyway regardless of execution failures or conflicts
	Platform    *committercommon.Platform
}

func NewStorageCommitter(store interfaces.Datastore) *StorageCommitter {
	platform := committercommon.NewPlatform()
	return &StorageCommitter{
		importer:    indexer.NewImporter(store, platform),
		imuImporter: indexer.NewImporter(store, platform),
		Platform:    platform, //[]committercommon.FilteredTransitionsInterface{&indexer.NonceFilter{}, &indexer.BalanceFilter{}},
	}
}

func (this *StorageCommitter) New(args ...interface{}) *StorageCommitter {
	return &StorageCommitter{
		Platform: committercommon.NewPlatform(),
	}
}

// func (this *StorageCommitter) WriteCache() *indexer.WriteCache { return this.writeCache }
func (this *StorageCommitter) Importer() *indexer.Importer { return this.importer }

func (this *StorageCommitter) Init(store interfaces.Datastore) {
	this.importer.Init(store)
	this.imuImporter.Init(store)
}

func (this *StorageCommitter) Clear() {
	this.importer.Store().Clear()

	// this.writeCache.Clear()
	this.importer.Clear()
	this.imuImporter.Clear()
}

func (this *StorageCommitter) Import(transitions []interfaces.Univalue, args ...interface{}) *StorageCommitter {
	invTransitions := make([]interfaces.Univalue, 0, len(transitions))

	for i := 0; i < len(transitions); i++ {
		if transitions[i].Persistent() { // Peristent transitions are immune to conflict detection
			invTransitions = append(invTransitions, transitions[i]) //
			transitions[i] = nil                                    // mark the peristent transitions
		}
	}
	common.Remove(&transitions, nil) // Remove the Peristent transitions from the transition lists

	common.ParallelExecute(
		func() { this.imuImporter.Import(invTransitions, args...) },
		func() { this.importer.Import(transitions, args...) })
	return this
}

// Call this as s
func (this *StorageCommitter) Sort() *StorageCommitter {
	common.ParallelExecute(
		func() { this.imuImporter.SortDeltaSequences() },
		func() { this.importer.SortDeltaSequences() })

	return this
}

func (this *StorageCommitter) Finalize(txs []uint32) *StorageCommitter {
	if txs != nil && len(txs) == 0 { // Commit all the transactions when txs == nil
		return this
	}

	common.ParallelExecute(
		func() { this.imuImporter.MergeStateDelta() },
		func() {
			this.importer.WhilteList(txs)   // Remove all the transitions generated by the conflicting transactions
			this.importer.MergeStateDelta() // Finalize states
		},
	)
	return this
}

func (this *StorageCommitter) CopyToDbBuffer() [32]byte {
	keys, values := this.importer.KVs()
	invKeys, invVals := this.imuImporter.KVs()

	keys, values = append(keys, invKeys...), append(values, invVals...)
	return this.importer.Store().Precommit(keys, values) // save the transitions to the DB buffer
}

func (this *StorageCommitter) SaveToDB() {
	store := this.importer.Store()
	store.Commit(0) // Commit to the state store
	this.Clear()
}

func (this *StorageCommitter) Commit(txs []uint32) *StorageCommitter {
	if txs != nil && len(txs) == 0 {
		this.Clear()
		return this
	}
	this.Finalize(txs)
	this.CopyToDbBuffer() // Export transitions and save them to the DB buffer.
	this.SaveToDB()
	return this
}
