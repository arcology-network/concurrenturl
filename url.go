package concurrenturl

import (
	"reflect"

	"github.com/arcology-network/common-lib/common"
	ccurlcommon "github.com/arcology-network/concurrenturl/common"

	commutative "github.com/arcology-network/concurrenturl/commutative"
	indexer "github.com/arcology-network/concurrenturl/indexer"
	interfaces "github.com/arcology-network/concurrenturl/interfaces"
	noncommutative "github.com/arcology-network/concurrenturl/noncommutative"
	"github.com/arcology-network/concurrenturl/univalue"
	cache "github.com/arcology-network/eu/cache"
)

type ConcurrentUrl struct {
	importer    *indexer.Importer
	imuImporter *indexer.Importer // transitions that will take effect anyway regardless of execution failures or conflicts
	Platform    *ccurlcommon.Platform
}

func NewConcurrentUrl(store interfaces.Datastore) *ConcurrentUrl {
	platform := ccurlcommon.NewPlatform()
	return &ConcurrentUrl{
		importer:    indexer.NewImporter(store, platform),
		imuImporter: indexer.NewImporter(store, platform),
		Platform:    platform, //[]ccurlcommon.FilteredTransitionsInterface{&indexer.NonceFilter{}, &indexer.BalanceFilter{}},
	}
}

func (this *ConcurrentUrl) New(args ...interface{}) *ConcurrentUrl {
	return &ConcurrentUrl{
		Platform: ccurlcommon.NewPlatform(),
	}
}

// func (this *ConcurrentUrl) WriteCache() *indexer.WriteCache { return this.writeCache }
func (this *ConcurrentUrl) Importer() *indexer.Importer { return this.importer }

func (this *ConcurrentUrl) Init(store interfaces.Datastore) {
	this.importer.Init(store)
	this.imuImporter.Init(store)
}

func (this *ConcurrentUrl) Clear() {
	this.importer.Store().Clear()

	// this.writeCache.Clear()
	this.importer.Clear()
	this.imuImporter.Clear()
}

func CreateNewAccount(tx uint32, acct string, platform *ccurlcommon.Platform, writeCache *cache.WriteCache) ([]interfaces.Univalue, error) {
	paths, typeids := platform.GetBuiltins(acct)

	transitions := []interfaces.Univalue{}
	for i, path := range paths {
		var v interface{}
		switch typeids[i] {
		case commutative.PATH: // Path
			v = commutative.NewPath()

		case uint8(reflect.Kind(noncommutative.STRING)): // delta big int
			v = noncommutative.NewString("")

		case uint8(reflect.Kind(commutative.UINT256)): // delta big int
			v = commutative.NewUnboundedU256()

		case uint8(reflect.Kind(commutative.UINT64)):
			v = commutative.NewUnboundedUint64()

		case uint8(reflect.Kind(noncommutative.INT64)):
			v = new(noncommutative.Int64)

		case uint8(reflect.Kind(noncommutative.BYTES)):
			v = noncommutative.NewBytes([]byte{})
		}

		if !writeCache.IfExists(path) {
			transitions = append(transitions, univalue.NewUnivalue(tx, path, 0, 1, 0, v, nil))

			if _, err := writeCache.Write(tx, path, v); err != nil { // root path
				return nil, err
			}

			if !writeCache.IfExists(path) {
				_, err := writeCache.Write(tx, path, v)
				return transitions, err // root path
			}
		}
	}
	return transitions, nil
}

func (this *ConcurrentUrl) Import(transitions []interfaces.Univalue, args ...interface{}) *ConcurrentUrl {
	invTransitions := make([]interfaces.Univalue, 0, len(transitions))

	for i := 0; i < len(transitions); i++ {
		if transitions[i].Persistent() { // Peristent transitions are immune to conflict detection
			invTransitions = append(invTransitions, transitions[i]) //
			transitions[i] = nil                                    // mark the peristent transitions
		}
	}
	common.Remove(&transitions, nil) // Remove the Peristent transitions from the transition lists

	common.ParallelExecute(
		func() { this.imuImporter.Import(invTransitions, args...) },
		func() { this.importer.Import(transitions, args...) })
	return this
}

// Call this as s
func (this *ConcurrentUrl) Sort() *ConcurrentUrl {
	common.ParallelExecute(
		func() { this.imuImporter.SortDeltaSequences() },
		func() { this.importer.SortDeltaSequences() })

	return this
}

func (this *ConcurrentUrl) Finalize(txs []uint32) *ConcurrentUrl {
	if txs != nil && len(txs) == 0 { // Commit all the transactions when txs == nil
		return this
	}

	common.ParallelExecute(
		func() { this.imuImporter.MergeStateDelta() },
		func() {
			this.importer.WhilteList(txs)   // Remove all the transitions generated by the conflicting transactions
			this.importer.MergeStateDelta() // Finalize states
		},
	)
	return this
}

func (this *ConcurrentUrl) CopyToDbBuffer() [32]byte {
	keys, values := this.importer.KVs()
	invKeys, invVals := this.imuImporter.KVs()

	keys, values = append(keys, invKeys...), append(values, invVals...)
	return this.importer.Store().Precommit(keys, values) // save the transitions to the DB buffer
}

func (this *ConcurrentUrl) SaveToDB() {
	store := this.importer.Store()
	store.Commit(0) // Commit to the state store
	this.Clear()
}

func (this *ConcurrentUrl) Commit(txs []uint32) *ConcurrentUrl {
	if txs != nil && len(txs) == 0 {
		this.Clear()
		return this
	}
	this.Finalize(txs)
	this.CopyToDbBuffer() // Export transitions and save them to the DB buffer.
	this.SaveToDB()
	return this
}
